// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "match_server/Match.h"
#include "save_client/Save.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/transport/TSocket.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/TToString.h>
#include <thrift/server/TThreadedServer.h>

#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>
#include <queue>
#include <unistd.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::match_service;
using namespace ::save_service;
using namespace std;

//任务类型
struct Task
{
    User user; //用户
    string type; //操作类型
};

//消息队列
struct MessageQueue
{
    queue<Task> q; //定义一普通队列，其中存储各种task
    mutex m; //唯一的锁
    condition_variable cv; //条件变量
}message_queue;

//定义一个玩家池
class Pool
{
    public:
        //保存匹配结果的函数
        void save_result(int a, int b) //传入两个人的id即可
        {
            printf("Match Result: %d %d\n", a, b);

            //localhost改为myserver的IP地址123.57.67.128
            std::shared_ptr<TTransport> socket(new TSocket("123.57.67.128", 9090));
            std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            //MatchClient client(protocol);改为
            SaveClient client(protocol);


            try {
                transport->open();

                int res = client.save_data("acs_11385", "bbc7baa1", a, b);

                if (!res) puts("success");
                else puts("failed");

                transport->close();
            } catch (TException& tx) {
                cout << "ERROR: " << tx.what() << endl;
            }
        }

        bool check_match(uint32_t i, uint32_t j)
        {
            //要求a能够匹配b，b也能匹配a
            auto a = users[i], b = users[j];

            int dt = abs(a.score - b.score);  //a和b分差的绝对值

            int a_max_dif = wt[i] * 50; //a允许的最大分数差距
            int b_max_dif = wt[j] * 50; //a允许的最大分数差距

            //dt需要同时在a所允许的最大范围内和b所允许的最大的范围内
            return dt <= a_max_dif && dt <= b_max_dif;
        }

        //匹配函数
        void match()
        {
            for (uint32_t i = 0; i < wt.size(); i ++ )
                wt[i] ++ ; //匹配一次，等待秒数+1

            while (users.size() > 1)
            {
                //排序会打乱玩家顺序，因此不排序，采用两重循环匹配的方式
                //避免死循环，定义一个flag用于判断
                bool flag = true;
                //用无符号整数，否则会报warning，下标从1开始，因为是比较当前玩家和前一名玩家的分数
                for (uint32_t i = 0; i < users.size(); i ++ )
                {
                    for (uint32_t j = i + 1; j < users.size(); j ++ )
                    {
                        //看玩家i和玩家j能否匹配在一起
                        auto a = users[i], b = users[j];
                        if (check_match(i, j))
                        {
                            //删去玩家i和玩家j，先删后面的j，再删后面的i，先删前面的玩家会导致后面的玩家下标变化
                            users.erase(users.begin() + j);
                            users.erase(users.begin() + i);

                            //删去相应玩家的waiting time
                            wt.erase(wt.begin() + j);
                            wt.erase(wt.begin() + i);

                            save_result(a.id, b.id); //存储匹配结果
                            flag = false;
                            break;  //完成匹配后立即break
                        }
                    }
                    if (!flag) break; //若flag为flase，说明已经发生过匹配，直接退出循环
                }
                if (flag) break; //若循环一遍发现没有两个玩家可以匹配在一起，则退出循环
            }
        }

        //添加一个玩家
        void add(User user)
        {
            users.push_back(user);
            wt.push_back(0); //对应的位置加入一个0，表示等待的时间为0
        }

        //删除一个玩家
        void remove(User user)
        {
            //通过user id来删除玩家，需要遍历所有user
            for (uint32_t i = 0; i < users.size(); i ++ ) 
                //users.size()返回的是无符号整数类型，故此处写int i会有warning，写工程最好0 warning
                if (users[i].id = user.id)
                {
                    users.erase(users.begin() + i);
                    wt.erase(wt.begin() + i); //删除玩家时，将该玩家的wt也删除掉
                    break; //只删除一个玩家
                }
        }

    private: //private用于存储所有的玩家，用vector存储玩家
        vector<User> users; //users由user填充，user的变量类型是match.thrift中定义的结构体User，其具有id, name, score三种属性
        vector<int> wt; //waiting time，等待的时间，单位：s

}pool;

class MatchHandler : virtual public MatchIf {
    public:
        MatchHandler() {
            // Your initialization goes here
        }

        int32_t add_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("add_user\n");

            //加锁：通过消息队列中定义的唯一的锁将消息队列锁起来，这样不用显示解锁
            //因为当函数执行完后，变量会消失，变量消失后会自动解锁
            unique_lock<mutex> lck(message_queue.m);

            message_queue.q.push({user, "add"});

            //执行add user时，队列不空了，因此写一个唤醒函数唤醒被卡住的线程
            message_queue.cv.notify_all(); //通知所有被条件变量卡住的线程，唤醒这些线程
            //也可以写作message_queue.cv.notify_one();即只唤醒所有被卡住的线程中的一个，由于此处只有一个线程被卡住，因此唤醒一个线程和唤醒所有线程没有区别

            return 0;
        }

        int32_t remove_user(const User& user, const std::string& info) {
            // Your implementation goes here
            printf("remove_user\n");

            //加锁，同上
            unique_lock<mutex> lck(message_queue.m);

            message_queue.q.push({user, "remove"});

            //唤醒被卡住的线程
            message_queue.cv.notify_all();

            return 0;
        }

};

class MatchCloneFactory : virtual public MatchIfFactory {
    public:
        ~MatchCloneFactory() override = default;
        MatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) override
        {
            std::shared_ptr<TSocket> sock = std::dynamic_pointer_cast<TSocket>(connInfo.transport);
            /*
            cout << "Incoming connection\n";
            cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
            cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
            cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
            cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
            */
            return new MatchHandler;
        }
        void releaseHandler(MatchIf* handler) override {
            delete handler;
        }
};

//消费者函数，需要一个单独的线程
void consume_task()
{
    //死循环，不断地看当前是否有玩家匹配在一起
    while (true)
    {
        //消费者函数由于也要涉及到队列的读写操作，因此也需要加锁
        unique_lock<mutex> lck(message_queue.m);

        //游戏刚上线没人来，队列大概率是空的，若队列是空的，就会跳过本次循环，释放掉锁然后下一次再获得这个锁
        //这样会导致死循环，导致cpu占用率达到100%，会占用所有的系统资源
        //因此若发现队列是空，则应该把这个线程阻塞住，直到有新的玩家进来再继续执行
        //用条件变量可实现对线程的阻塞
        if (message_queue.q.empty()) //若消息队列为空
        {
            //message_queue.cv.wait(lck); //先将锁释掉，然后线程被卡住，一直卡到在其他地方将这个条件变量唤醒
            lck.unlock(); //直接解锁
            pool.match(); //只在此处匹配，能够保证匹配一次等待1秒再匹配下一次
            sleep(1); //每一秒钟尝试匹配一次
        }
        else
        {
            auto task = message_queue.q.front(); //取出队头
            message_queue.q.pop(); //删去队头

            //解锁，若do task后再解锁，意味着我们持有锁的时间太长，在执行do task的时候就不能add user和remove user，导致效率低下
            //因此处理完共享的变量后一定要及时解锁
            lck.unlock();

            // do task
            // 若task的类型是添加或者删除
            if (task.type == "add") pool.add(task.user);
            else if (task.type == "remove") pool.remove(task.user);

            /*删去，否则每add或remove user时秒数都会加1
            //每次add或者remove后匹配一遍
            pool.match();
            */
        }
    }
}

//生产者函数，也需要一个单独的线程，生产者就是add_user和remove_user，每次add或者remove就会给生产者和消费者提供一个任务，生产者和消费者之间需要一个通信的媒介
//通信媒介可以用消费队列，虽然每种语言都有现成的消费队列，但手动实现也不复杂，这里我们会手动实现一个消费队列
//实现消费队列需要锁（mutex），锁是并行编程中的基本概念，互斥锁（英语：Mutual exclusion，缩写Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。
//锁有两种操作，即p操作和v操作。p操作指争取锁的操作，争取到了锁就可以运行程序了。


int main(int argc, char **argv) {
    TThreadedServer server(
            std::make_shared<MatchProcessorFactory>(std::make_shared<MatchCloneFactory>()),
            std::make_shared<TServerSocket>(9090), //port
            std::make_shared<TBufferedTransportFactory>(),
            std::make_shared<TBinaryProtocolFactory>());

    cout << "Start Match Server" << endl;

    //给死循环单独开一个线程，可以记下这种写法，这个线程名为匹配线程，传入函数名称（指针）即可，死循环也一定需要一个单独的线程，否则其后面的部分无法正常运行得到结果
    //若业务很多，可能用到更多的线程
    thread matching_thread(consume_task);

    server.serve();
    return 0;
}

